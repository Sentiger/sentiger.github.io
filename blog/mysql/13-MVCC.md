---
title: undo日志
order: 13
date: 2023-02-27
category:
  - MySQL
---

其实针对于事物，就有了隔离性。一个事物的操作不能对另一个事物产生影响，所以最简单的做法就是加锁，串行执行。但是这样会造成性能问题。MySQL在隔离性上面做了不同程度上的区分。


## 不使用隔离性造成的问题

如果事物中不使用隔离性，会造成以下问题：

### 脏写

一个事物修改了另一个未提交事物修改过的数据。


### 脏读

一个事物读取到了另一个未提交事物修改过的数据。


### 不可重复度

一个事物只能读取到已经提交事物修改过的数据，第二次来读取的时候，读取到了别的事物对该事物进行的修改。意思就是不能二次读取。不可重复读


### 幻读

一个事物根据某条件查询到了一系列数据，但是通过第二次同样查询读取到了比第一次读取更多的记录，称为幻读。如果第二次读取少了，则还是发生了不可重复读。


## MySQL设置隔离级别

针对于上面的隔离性，MySQL可以设置不同等级的隔离性


### READ-COMMITTED

### READ-UNCOMMITTED

### REPEATABLE-RAD

### SERIALIZABLE


## 设置食物隔离级别


## MVCC版本

每一条修改操作的语句都会产生对应的undo日志，通过当前select操作产生的`readview`读取不同规则的版本的数据，从而保证隔离性

意思就是当前的select读取MVCC版本链中的哪条数据。


1. 当开启一个事物的时候，如果有更新语句，则会产生一个全局自增的事物ID，tx_id
2. 当事物中进行select查询的时候，会将系统中当前活跃的tx_id存起来`tx_ids`
3. 在tx_ids中有一个最小tx_id，称为min_tx_id,当undo日志中的tx_id小于min_tx_id,则表明该undo日志的事物是提交的
4. 还有一个max_tx_id，这个是当前事物全局中的最大事物ID，自增就行
5. 对于通过版本记录寻找记录版本，如果undo日志中的tx_id在`readview`中，则表明是当前活跃的事物进行的修改。


所以针对不同进制的隔离性，基本很好理解数据读取了。

```
read-uncommitted
读取的是最新版本记录的数据就行，不需要进行版本查找。

serializable
这个是相当于加了锁，一个事物操作完才能操作另一个

read-committed
每次select都会产生readview

repeatable-read
只会产生一次readview，之后每次select都会使用

readview查询数据是：从当前记录进行查找，然后查看当前记录的tx_id,然后再依次对比undo日志链表中的tx_id，就知道取哪些数据了。



在 READ UNCOMMITTED 隔离级别下， 脏读 、 不可重复读 、 幻读 都可能发生。
在 READ COMMITTED 隔离级别下， 不可重复读 、 幻读 可能发生， 脏读 不可以发生。
在 REPEATABLE READ 隔离级别下， 幻读 可能发生， 脏读 和 不可重复读 不可以发生。 （幻读A插入id=10,B读取id=10读取不到，Acommit之后，B也读取不到，但是可以进行update 10这条记录）
在 SERIALIZABLE 隔离级别下，上述问题都不可以发生。
```
