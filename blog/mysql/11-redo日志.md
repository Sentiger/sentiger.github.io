---
title: redo日志
order: 11
date: 2022-07-19
category:
  - MySQL
---

## redo日志概述

redo日志就是物理日志，默认是数据目录下`ib_logfile0`和`ib_logfile1`。这个日志有以下特点：

1. 启动的时候，固定分配大小的（可以调整），目的是存储空间连续，读取和写入该文件可以近似顺序IO读取，加快操作速度。
2. 可以重复利用的，意思就是在写满`ib_logfile1`的时候，又可以从头`ib_logfile0`开始写。

## redo主要作用

MySQL为了执行效率，引入了缓存的概念，就是把物理文表中的数据读取到MySQL内部的`innodb_buffer`中，然后MySQL操作的就是内存中的数据。

但是放入到缓存中的数据肯定不安全，万一down机了，那就没了。但是不能每次更新数据库都里面进行刷新磁盘的操作吧。特别是一个语句修改了物理数据文件很多页面，这些页面还不连续，随机io巨强。
这样数据一旦大起来，数据库基本没用。

可以把MySQL的一次原子操作直接写入到redo日志中（不是完整的页，是一些物理和逻辑的表示，从而比较小），然而追加redo日志中很快（因为是连续的存储，顺序io）。

MySQL要是down机了，还可以通过redo日志进行恢复数据。**所以redo日志主要是防止MySQL服务中`innodb_buffer`中的数据同步到`物理文件`中的一个挽救措施~~~**

## 概念补充

- 执行一条更新sql语句的时候，不是仅仅只产生一条`redo`日志，一般都会产生很多条，这些`redo`日志组成了一个组，也就是`原子操作`
- 每次产生一条redo日志时候，不会立马写入到`redo`文件中，因为这个时候还不完整，估计这个组有好多条。而是先写入到内存中，然后再复制这些redo日志到`log buffer`redo日志缓冲区中。
- `log buffer`redo日志缓冲区为啥要个这个？不直接就将`redo日志组`直接写入到文件中，还要复制到这个缓冲区呢？因为MySQL提供了将redo日志刷新到redo文件中的机制`innodb_flush_log_at_trx_commit`


## redo日志类型

redo日志可以分为物理日志（?表空间?页修改了什么）和逻辑日志，需要通过一定的算法函数才能恢复成物理的样子。因为有时候操作的时候，设计到了很多页面的修改，这个时候用逻辑日志比较减少redo日志的大小。

redo日志为了记录这些，分了很多类型，主要是为了减少redo日志的大小，根据这些不同类型可以做不同的恢复操作。而不是直接就粗暴的将变动过的页直接写入到redo中。


## LSN

因为MySQL操作数据都是先操作内存中的数据，最小单位是mtr，就是操作完一个mtr之后，然后将mtr产生的redo日志写到`log buffer`中，是以512字节的Block写。所以每次LSN 就增加该长度。

所以LSN就是可以记录整个数据库在修改过程中产生的脏页的redo日志长度。是一个全局自增的。

## checkpoint_lsn

checkpoint_lsn和lsn是一个类似的全局变量，因为被修改的脏页都记录到了`flush`链表中了，且是排序好的。当flush中的脏页被同步到本地数据文件中，则已经写入本地`redo`日志中就没有用了，完全可以覆盖。

所以当出现本地`redo`日志文件写满的情况，又从头`ib_logfile0`开始写的时候，小于`checkpoint_lsn`都是可以进行覆盖的。



