---
title: 面试
order: 102
date: 2023-02-27
category:
---

## 三色标记

程序都是从函数执行的，函数执行都是栈上分配空间，理论来说如果函数执行完，ret之后，被调用函数的栈空间就释放掉了。

但是程序中很多变量都是分配到了堆上，堆上的空间在使用完之后就需要进行手动回收或者由语言提供的自动回收机制进行回收。

所以回收堆上的空间，最简单的就是从栈空间root节点开始循环遍历，遍历到的内存区域就不回收，否则就直接回收。

**标记清除算法**

1.3之前版本就是采用最简单粗暴的标记清除算法，好处就是简单，劣势就是需要先标记，然后再做清除操作，此时程序就需要暂停操作。`stw`造成程序卡顿现象

**三色并发标记法+STW**

v1.5版本引入三色并发标记法，就是内存中引入抽象概念三种区域的空间，白色，黑色，灰色

第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。

第二步, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合，但是不会递归遍历

第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合

第四步, 重复第三步, 直到灰色中无任何对象

最终所有被程序使用到的对象都会被标记成黑色，白色区域的对象就可以被GC给回收。

但是三色并发标记在GC的时候，还是需要STW机制，因为并发操作的时候，任意时刻对象都是可以进行创建对象的操作。例如刚刚标记完第一轮黑色的时候，
再扫描灰色对象的时候，这个时候黑色对象又创建了白色对象，因为黑色对象无需再扫描。导致最终黑色创建的白色对象被GC，导致程序异常。


**屏障机制**

我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“弱三色不变式”。

***“强-弱” 三色不变式***

- 强三色不变式：在GC期间，不允许黑色对象引用白色对象
- 若三色不变式：黑色对象可以引入白色对象，但是白色对象要有被他引用的灰色对象，或者上上游可以找到引用的灰色对象

**插入屏障**

针对于强，弱三色不变式，我们的方案是插入屏障：

黑色对象引入白色对象的时候，直接将白色对象标记为灰色对象。满足强三色不变式。

针对如插入屏障，黑色如果处于堆上，则引入的白色对象直接设置为灰色。如果在栈上，由于栈空间小，不直接标记为灰色，等GC标记完一轮，然后启用STW机制扫描栈上的

**删除屏障**

黑色对象或者白色对象删除白色对象的引入，也是直接将白色对象设置为黑色，这种缺点在于最终可能有大量的黑色对象其实是无用的。回收颗粒度比较低


**混合写屏障**

插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点

1. GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)， 
2. GC期间，任何在栈上创建的新对象，均为黑色。 
3. 被删除的对象标记为灰色。 
4. 被添加的对象标记为灰色


## 内存结构


## defer

## 变量逃逸

## GMP模型
