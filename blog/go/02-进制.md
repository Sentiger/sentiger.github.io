---
title: 进制应用
order: 2
date: 2022-09-29

---

二进制在汇编和语言底层用的比较多，虽然这个不好识别，但是简单，而且存储空间也小，每一位都代表一个含义。下面介绍在go中的场景

## 运算符

```
与运算
0&0=0；0&1=0；1&0=0；1&1=1
即：两个同时为1，结果为1，否则为0

或运算（|）
0|0=0；  0|1=1；  1|0=1；   1|1=1；
即 ：参加运算的两个对象，一个为1，其值为1。

异或运算符（^）
运算规则：0^0=0；  0^1=1；  1^0=1；   1^1=0；
即：参加运算的两个对象，如果两个位为“异”（值不同），则该位结果为1，否则为0。
```

## 文件中用法

| 常量       | 二进制          | 用途                                                          | 说明  |
|----------|--------------|-------------------------------------------------------------|-----|
| O_RDONLY | 0            | 打开文件（只读模式）                                                  |     |
| O_WRONLY | 1            | 打开文件（只写模式）                                                  |     |
| O_RDWR   | 10           | 打开文件（可读可写）                                                  |     |
| O_APPEND | 1000         | 已经打开的文件（在文件后面追加内容）                                          |     |
| O_CREATE | 1000000000   | 针对前面三个打开文件模式，如果文件不存在则创建一个                                   |     |
| O_EXCL   | 100000000000 | 这个用来限制O_CREATE，如果使用了O_CREATE，则这个参数会限制文件必须不存在                |     |
| O_SYNC   | 10000000     | 写入文件内容的时候，每次写点内容，必须等待系统io返回。要不然是系统缓冲中。这个参数会保证文件能写入成功，但是速度不行 |     |
| O_TRUNC  | 10000000000  | 打开文件的时候，会清空文件                                               |     |

**打开文件流程**

1. 在打开文件模式必须指定O_RDONLY，O_WRONLY，O_RDWR中的一个
2. O_APPEND，O_CREATE，O_EXCL，O_SYNC，O_TRUNC这个来控制打开文件的行为
3. 指定权限

**运算符的用法**

```
           0   O_RDONLY  末尾是0表示可读
           1   O_WRONLY  末尾是1表示可写
          10   O_RDWR    倒数第二位是1表示可读可写

        1000   O_APPEND
    10000000   O_SYNC
  1000000000   O_CREATE
 10000000000   O_TRUNC
100000000000   O_EXCL

file, err := os.OpenFile("test.txt", os.O_CREATE|os.O_RDONLY|os.O_APPEND, 0666)
在这里flag就是一个整数，只是这里用了定义的常量做｜运算了。这里就是定义的常量就要有规律，这也是二进制最比较烦得，要根据实际情况来定义二进制数，然后才能配合运算符来达到意想不到的结果


1. 通过对比上面的二进制发现，他们每位是没有重复的。所以就是每一位表示不同的含义。例如我想定义可写模式打开，且文件内容是追加的
flag = 1 | 1000 = 1001

2. 例如在调用write方法的时候，会先进行判断。其他的也是一样的
if flag & O_WRONLY ==0 { // 因为只要判断O_WRONLY这一位是否设置为1了
    panic("文件模式不能写")
}


3. 总结：其实这的好处就是通过数字中的位来表示操作的意图，而不是直接使用更加上层的操作来表示，我们在设计的时候也可以借鉴。

```

**借鉴**

```
假设编程中有十种状态，且是可以组合的，应该如何设计
1. 定义十个位置数（二进制）
1111111111

2. 不同状态
状态1： 1
状态2：10
状态3：100
状态4：1000
...
状态10：1000000000

2. 然后传入参数
状态1 状态2
1 ｜ 10

3. 判断是否有传入状态1
if 1 & flag !=0 

判断状态10
if 1000000000 & flag != 0

```

**文件权限/fileMode**

在创建文件的时候需要指定权限。这里的权限和Linux的权限表达一致。然后也是用上面一样的进制位来表示有哪些权限

```
语意表达法
-rwx rwx rwx
对应的二进制表达法
-111 111 111
对应十进制
r:4
w:2
x:1

示例：
os.OpenFile("test.txt", os.O_CREATE|os.O_RDONLY|os.O_APPEND, 0777)

fileModel是一个uint32位的整数
0777：表示8进制，正好可以完美的表示111 111 111 的每三位


注意umask
os.OpenFile("test.txt", os.O_CREATE|os.O_RDONLY|os.O_APPEND, 0777)
上面这个创建的文件一般都是0755。为啥不是0777呢？

答案：其实这个是磁盘的默认的保护方法。所以umask 022。然后做一次运算 0777 & (^022) = 0755

所以如果需要和结果一致

syscall.Umask(0)
os.OpenFile("test.txt", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)

```

