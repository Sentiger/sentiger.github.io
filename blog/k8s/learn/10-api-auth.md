---
title: API访问控制
order: 10
category:
  - k8s

---

访问API资源都是通过REST请求的，所以对这里的访问认证，权限控制等操作需要了解

## 身份认证

身份认证是用来确定请求的用户是否是k8s中的合法用户。k8s中的用户设计比较灵活，是一个与k8s系统无关的服务。只要满足系统中的用户规范，就可以通过任意外部系统来添加用户。

### 普通用户身份认证的方法

**静态令牌文件**

静态令牌文件是在`kube-apiserver`启动的时候加载的令牌文件，是一个csv文件，里面包含 `token,用户名,用户ID,"用户组1,用户组2"`。配置api启动中加载

```
vim /etc/kubernetes/manifests/kube-apiserver.yaml

apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: 192.168.56.11:6443
  creationTimestamp: null
  labels:
    component: kube-apiserver
    tier: control-plane
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
    ...
    - --token-auth-file=/etc/kubernetes/pki/tokenauth.csv # 这里就是配置的静态token
    ...

# token文件
[root@master1 yaml]# cat /etc/kubernetes/pki/tokenauth.csv
31ada4fd-adec-460c-809a-9e56ceb75269,sentiger,12,"dev1,dev2"

# 请求发现用户sentiger认证成功了。只是没有权限请求资源而已，是系统能认识的用户
[root@master1 yaml]# curl -H "Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269"  https://192.168.56.11:6443/api/v1/namespaces/default/pods?limit=500 -k
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "pods is forbidden: User \"sentiger\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}

```

:::danger

注意： 这里使用的是静态pod启动kube-apiserver,对于新增的配置kubelet会自动重启pod，如果启动失败，日志该如何查？其实启动的pod就是容器，完全根据容器是怎么查看日志的方式来查找就行

例如使用的是containerd, 则可以使用`crictl logs 容器ID`来查看

更新token.csv需要重启`kube-apiserver`服务

:::

**Bootstrap Tokens**

启动引导令牌是一个比较简单的，可以动态添加到k8s系统中的。相比静态文件不能动态添加，和实施加载方便多了。使用Bootstrap Tokens需要如下配置

```
# 1. kube-apiserver中开启bootstrap-tokens
vim /etc/kubernetes/manifests/kube-apiserver.yaml
--enable-bootstrap-token-auth=true

# 2. 控制其中设置secret过期自动清理控制器
vim /etc/kubernetes/manifests/kube-controller-manager.yaml
- --controllers=*,bootstrapsigner,tokencleaner

# 3.配置secret

apiVersion: v1
kind: Secret
metadata:
  # name 必须是 "bootstrap-token-<token id>" 格式的
  name: bootstrap-token-07401c
  namespace: kube-system

# type 必须是 'bootstrap.kubernetes.io/token'
type: bootstrap.kubernetes.io/token
stringData:
  # 供人阅读的描述，可选。
  description: "The default bootstrap token generated by 'kubeadm init'."

  # 令牌 ID 和秘密信息，必需。
  token-id: 07401c
  token-secret: f395accd246ae52d

  # 可选的过期时间字段
  expiration: 2027-03-10T03:22:11Z

  # 允许的用法
  usage-bootstrap-authentication: "true"
  usage-bootstrap-signing: "true"

  # 令牌要认证为的额外组，必须以 "system:bootstrappers:" 开头
  auth-extra-groups: system:bootstrappers:worker,system:bootstrappers:ingress

# 4. 请求用户认证通过
[root@master1 yaml]# curl -H "Authorization: Bearer 07401c.f395accd246ae52d" https://192.168.56.11:6443/api/v1/namespaces/default/pods?limit=5 -k
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "pods is forbidden: User \"system:bootstrap:07401c\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}
```

**X509 客户证书**

X509 客户证书也是比较常见的一种客户端认证方式，通过使用k8s中的ca来签发客户端证书来请求。下面介绍如何来使用：

手动签发
```
# 生成客户端的证书请求文件，CN：用户名，O是组织
openssl genrsa -out sentiger.key 2048
openssl req -new -key sentiger.key -subj '/CN=sentiger/O=dev1/O=dev2' -out sentiger.csr

# 使用kube-apiserver的CA来签署客户端请求文件，生成客户端证书
openssl x509 -req -sha256 -in sentiger.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -days 3650 -out sentiger.crt

# 测试：注意这里cert路径这里相对路径要写./或者绝对路径（所以只要有了证书和私钥都可以进行签发用户）
curl --cert ./sentiger.crt --key ./sentiger.key  --cacert /etc/kubernetes/pki/ca.crt https://192.168.56.11:6443/api/v1/namespaces/default/pods?limit=5
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "pods is forbidden: User \"sentiger\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}
```

使用k8s系统签发
```
# 1. 生成客户端证书请求文件
openssl genrsa -out sentiger.key 2048
openssl req -new -key sentiger.key -subj '/CN=sentiger/O=dev1/O=dev2' -out sentiger.csr

# 2. 将csr生成base64
cat sentiger.csr | base64 | tr -d "\n"

# 3. 创建客户端证书请求
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: sentiger

spec:
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ2RqQ0NBVjRDQVFBd01URVJNQThHQTFVRUF3d0ljMlZ1ZEdsblpYSXhEVEFMQmdOVkJBb01CR1JsZGpFeApEVEFMQmdOVkJBb01CR1JsZGpJd2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUN1CjhKdVprbTFkM0FzY1pYZEM1bzRZT3VKY2o0dHY3YThPWFFkTVNlZmVWMHFQMVRaMVp3WkozYWV1cWk3TDV1RkkKaUlkeXB5dlJ5SHFxVnp6OGxGa3c3M1ZxSloxY1Rjb1g1Qk1yeDJqVnB0R0VDaW1NWDROdDV0S0FIR1JSQ1V6Mwpta2YxZkIrZXBVcDZhTjVrY1p3QlY5MERxN25jZzNxeGZhMHVrYnUybUdraFJVeS9Yb0ZoZEUwZktZRC80Vzl2CndZR1FlaUJhSzlkUFdnN0w1bTh5NkxJQWoxU05kQ0lwNkpCbmlmL1ROY0dTaUtkUVVXdTdHWDB5Q0pXQ205Q2MKQitJWWRwRGhOODR0M011Yk1Ca25PbUJ3U1pZbU1BVkpQMkN2YllrV0g4ZlcrNVJGZktVbS9YN1dqa1dQcXRWOQpWRjlyUXNFRDRUNld0SEF6TUtETkFnTUJBQUdnQURBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQWVNT2xPQ3R0CkpKZUFJVEd5QzlQamRsMjd1RExiT29OdkllTUtMMXdCSmU0NHAzWm9DNHIwWFlyL0xyenRDaXJicTBid2p0bEQKYm1YM0xqNUoycmlEUmZkSHkzM2hDR2FVdFo0V053SFBwZFBVUi9BWmh0S0VtNjFLZnUzT3pyR1UwbUNOcXJRUQpYZDJ5TzhUbVl3bHExSXJxWGdac2pmR1Q0ZXJMaHA2TFo0THVUYi8xbkgxZ2tHalI1NElFN0QwMk1JN2xTdlAyCkJaNkE5QlQ4WWhPdzQ3REZxcERmY1BYOXlhbmNkTGlBR21HN0xtQnAwRWxFeWxMQjI1KzdmNG9NYXJST3dqa3gKV291KzVTTDVjMldjemhHMXNKU2F5a2tlNENJaUIrRHVyWExLQm9hMUhzelBKQ2ZkV2pUWlJTQVJ5akt5R3BDZwpIR3hyOTg1RExLZEdtUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
  signerName: kubernetes.io/kube-apiserver-client
  expirationSeconds: 86400
  usages:
  - client auth
  
# 4. 创建
[root@master1 yaml]# kubectl apply -f  sentiger-csr.yaml 
certificatesigningrequest.certificates.k8s.io/sentiger created
[root@master1 yaml]# kubectl get csr
NAME       AGE   SIGNERNAME                            REQUESTOR          REQUESTEDDURATION   CONDITION
sentiger   7s    kubernetes.io/kube-apiserver-client   kubernetes-admin   24h                 Pending

# 5.签发证书
> 通过
kubectl certificate approve sentiger
> 拒绝
kubectl certificate deny sentiger

# 6.导出证书
kubectl get csr sentiger -o jsonpath='{.status.certificate}'| base64 -d  > sentiger.crt

# 验证
[root@master1 yaml]# curl --cert ./sentiger.crt --key ./sentiger.key  --cacert /etc/kubernetes/pki/ca.crt https://192.168.56.11:6443/api/v1/namespaces/default/pods?limit=5
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "pods is forbidden: User \"sentiger\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}
```

### 服务账号

服务账号主要是针对于pod进程来设计的，在生成的pod中会自动的加入服务账号信息，默认是有一个default服务账号也可以手动的指定

```
# 1. 创建服务账号
kubectl create token jenkins

# 2. 通过服务账号创建token（JTW）
kubectl create token jenkins

# 3. 外部也可以使用这个token来访问
使用环境变量方便后续操作
mytoken=eyJhbGciOiJSUzI1NiIsImtpZCI6Ik54UUMtT2s1Tm9tcHMwUzUxdGVjOEdTbGFmSmhGTmJNYkN4S1plb3RlaW8ifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjY5MTA1MjA0LCJpYXQiOjE2NjkxMDE2MDQsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0Iiwic2VydmljZWFjY291bnQiOnsibmFtZSI6ImplbmtpbnMiLCJ1aWQiOiJhMjYzZGI1Ni0yNWVjLTQwYjUtODliMi1mOTM4MTMyNTMwMjQifX0sIm5iZiI6MTY2OTEwMTYwNCwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6amVua2lucyJ9.GN1-DTjne48q0VcCtaa2eL89tZMObNyil-_7aP4oNwifY7KKJwaF4Kf-p4bLkTPVIjSamkneqg9xdrn2cE8IEF-YqNoHv2FD-NvjbbDRT-AmFmgLzuU4TXkwoTAUY-UmyRB9BLy7Xp8aJBKAYLvdfc57a7ci2jGP7CzFhniv5KiQ4Nlf4qBVU03jF3OjhK1K5epaMGYyRfQtQLC9U1TcXvl3Bdj410BtRMDqQ14hE5DE7NafrT3woKWWYf33oIEs_TMTtiesGzXubXBzcpTCZhVQT650THuBrNmjKSLgren8vUsjfhNdQRSN_EdGLTvYeJ4p6qSYGGtOZUgcJjSVvQ
使用JTW请求
curl -H "Authorization: Bearer $mytoken" https://192.168.56.11:6443/api/v1/namespaces/default/pods --cacert /etc/kubernetes/pki/ca.crt 
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "pods is forbidden: User \"system:serviceaccount:default:jenkins\" cannot list resource \"pods\" in API group \"\" in the namespace \"default\"",
  "reason": "Forbidden",
  "details": {
    "kind": "pods"
  },
  "code": 403
}

# 4. pod中使用服务账号

kind: Deployment
metadata:
  name: deployment-sa
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pod-sa
  template:
    metadata:
      name: pod-sa
      labels:
        app: pod-sa
    spec:
      serviceAccountName: jenkins
      containers:
      - name: nginx
        image: nginx:stable

进入容器查看
cd /var/run/secrets/kubernetes.io/serviceaccount
root@deployment-sa-698cd9c74d-hx8xz:/var/run/secrets/kubernetes.io/serviceaccount# ls
ca.crt  namespace  token

有了ca.crt, namespace, token 所以在容器内可以直接访问apiserver

# 注意：（后续分配权限）
被认证的用户名是：system:serviceaccount:<名字空间>:<服务账号>
并被分配到用户组 system:serviceaccounts 和 system:serviceaccounts:<名字空间>

# v1.22 之前默认创建sa，会创建token到secret中，然后pod自动挂载secret。但是后续也可以手动管理。
v1.22之前这样创建的token是永久的，后续为了安全起见，使用了Token Request来动态创建，并且在pod删除的时候，自动删除token


```
手动创建sa,和secret，但是好像没啥作用，在1.24版本中就使用动态token，这样相比于永久token更加安全

```
[root@master1 yaml]# cat sa-secret.yaml 
apiVersion: v1
kind: ServiceAccount
metadata:
  name: sentiger
  namespace: default

---
apiVersion: v1
kind: Secret
metadata:
  name: sentiger-secret
  annotations:
    kubernetes.io/service-account.name: sentiger
type: kubernetes.io/service-account-token

```

**通过服务账号找到对应的binding**

```shell
kubectl get rolebindings,clusterrolebindings \
  --all-namespaces  \
  -o custom-columns='KIND:kind,NAMESPACE:metadata.namespace,NAME:metadata.name,SERVICE_ACCOUNTS:subjects[?(@.kind=="ServiceAccount")].name' | grep "<SERVICE_ACCOUNT_NAME>"
```


## RBAC

### Role

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dev1
  namespace: default

rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]

# apiGroups: "","apps", "autoscaling", "batch", kubectl api-versions
# resources: "services", "pods","deployments"... kubectl api-resources 且可以配置子资源 pods/log
# verbs: "get", "list", "watch", "create", "update", "patch", "delete", "exec"
```

### RoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default

subjects:
- kind: User
  name: sentiger
  apiGroup: rbac.authorization.k8s.io

roleRef:
  kind: Role
  name: dev1
  apiGroup: rbac.authorization.k8s.io
```

## ServiceAccount

服务账号主要是针对于pod里面的服务请求api

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin
  namespace: default

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin

roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: "rbac.authorization.k8s.io"

subjects:
- kind: ServiceAccount
  name: admin
  namespace: default

---
apiVersion: v1
kind: Pod
metadata:
  name: nginx-sa

spec:
  # 1.24版本 绑定服务账号，最终会绑定到容器中 /run/secrets/kubernetes.io/serviceaccount/路径中 里面有token,和ca，1.24版本不会自动创建secret
  serviceAccountName: admin # 绑定服务账号 
  containers:
    - name: nginx-sa
      image: nginx:1.18-alpine
```

**通过服务账号就可以访问对应的api接口**

```shell
curl --cacert ca.crt -H 'Authorization: Bearer 服务账号token' https://172.31.0.3:6443/api/v1/namespaces/default/pods?limit=3
# ca.crt，token都是在pod容器内 /var/run/secrets/kubernetes.io/serviceaccount 目录下
```

## kubectl

使用kubectl命令来操作kube-api，其实也是配置了认证方式，在$HOME/.kube/config文件中

```yaml
apiVersion: v1
kind: Config
clusters:  # 可以配置管理多个集群
- cluster:
    certificate-authority-data: 这里是CA根证书base64编码后的内容
    server: https://172.31.0.3:6443 # 集群api地址
    name: kubernetes  # 定义的集群名称，下面内容会对其引用

contexts: # 配置上下文关系（环境），集群-用户
- context:
    cluster: kubernetes # 这里是对上面配置的clusters中的cluster.name的引用
    user: kubernetes-admin # 这里是引用的user.name
  name: kubernetes-admin@kubernetes # 这里是将context定义一个名字，后面具体使用哪个环境，则引用这个名字
  
users: # 定义用户
- name: kubernetes-admin # 定义一个名称，这个名字仅仅是给到context的一个引用，与下面的用户名没有任何关系
  user:
    client-certificate-data: 该用户的证书文件crt base64编码后的
    client-key-data: 该用户生成的私钥文件 base64编码后的
    #client-certificate: /root/ssl/sentiger.crt # 这里或者指定证书路径
    #client-key: /root/ssl/sentiger.key

current-context: kubernetes-admin@kubernetes # 这里就是kubectl使用的环境

```
### 相关命令

其实完全可以通过直接编辑config文件来配置，但是kubectl提供了很多方便的命令：

```
# config 系列命令
kubectl config

添加用户到config中 --embed-certs=true 添加这个参数是直接将证书内容添加到config，否则是路径 
kubectl config set-credentials sentiger --client-key sentiger.key --client-certificate sentiger.crt

删除用户
kubectl config delete-user sentiger

# 添加上下文（环境）
kubectl config set-context sentiger --cluster=kubernetes --user=sentiger

# 使用上下文
kubectl config use-context sentiger 

```


## 扩展

**相关名词**

```
authorization [n] 英 [ˌɔːθəraɪˈzeɪʃn] : 授权；批准；授权书

authentication [n] 英 [ɔːˌθentɪˈkeɪʃn] 认证 ; 身份验证 ; 鉴别 ; 身份认证 ; 鉴权 ; 验证

你要登机，你需要出示你的身份证和机票，身份证是为了证明你张三确实是你张三，这就是 authentication；而机票是为了证明你张三确实买了票可以上飞机，这就是 authorization。

certificate [n/v] 英 [səˈtɪfɪkət , səˈtɪfɪkeɪt] 颁发证书 / 证明 / 发给证明书 / 用证书批准 [v] 给…提供证书
# 授权通过
kubectl certificate approve myuser 
 
certification [n] 证明；证书；鉴定；检定

certification 主要是“证明，证明书”之意，而certificate为“证书，执照，合格证，凭证”，即使名词又是动词，动词给xxx颁发证书

authority [n] 管辖权；当局；当权者；威信；影响力；说服力；批准；专家；权；权力

credential 英 [krəˈdenʃl] [n] 凭据；资质；证件；国书 主要是资质证明
# 在文件中添加证书
kubectl config set-credentials myuser --client-key=myuser.key --client-certificate=myuser.crt --embed-certs=true
```

## apiserver新增域名/ip

**https验证主要过程**

1. 客户端请求服务端，服务端返回客户端证书文件（crt） 
2. 客户端验证crt证书找到本地的ca根证书，一般浏览器都会安装（这个过程就是验证服务端证书是否是根证书颁发的）openssl verify -CAfile ca.crt server.crt 
3. 客户端获取服务端证书，然后要验证当前请求host是否和服务端返回的证书中的subject或subjectAltName能匹配上，如果匹配不上，则host错误
4. 验证通过则提取服务端证书公钥验证发送过来的内容。（生成接下来的对称加密公钥） 
5. 交换对称加密算法的公钥和选择对称加密的算法 
6. 使用对称加密算法加密传输内容


**更换证书**

```shell
# 查看证书信息
openssl x509 -noout -text -in apiserver.crt

# 备份证书
cp -R /etc/kubernetes/pki /etc/kubernetes/pki-backup

# 获取kubadm的配置文件
kubectl -n kube-system get configmap kubeadm-config -o jsonpath='{.data.ClusterConfiguration}' > kubeadm.yaml

# 修改kubeadm.yaml,certSANs

apiServer:
  certSANs:
  # 新增IP，这里默认我服务器上是空的，最好是查看历史证书中的这些字段，都加上。默认的DNS是加上了。
  - "127.0.0.1"
  - "192.168.56.11"
  extraArgs:
    authorization-mode: Node,RBAC
  timeoutForControlPlane: 4m0s
apiVersion: kubeadm.k8s.io/v1beta3
certificatesDir: /etc/kubernetes/pki
clusterName: kubernetes
controllerManager: {}
dns: {}
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.aliyuncs.com/google_containers
kind: ClusterConfiguration
kubernetesVersion: v1.25.3
networking:
  dnsDomain: cluster.local
  podSubnet: 172.30.0.0/16
  serviceSubnet: 172.16.0.0/16
scheduler: {}


# 删除apiserver.crt, apiserver.key并生成新的
kubeadm init phase certs apiserver --config kubeadm.yaml

# 默认是会将dns自动加上
[certs] Generating "apiserver" certificate and key
[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local master1] and IPs [172.16.0.1 10.0.2.15 127.0.0.1 192.168.56.11]

# 删除apiserver的pod（会自动重启）
kubectl -n kube-system delete pod kube-apiserver-master1

```



**参考**
- [文档]
- [认证]

[文档]: https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process
[认证]: ../../other/02-openssl.md


